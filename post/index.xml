<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on TLSeminar</title>
    <link>https://tlseminar.github.io/post/index.xml</link>
    <description>Recent content in Post-rsses on TLSeminar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 Feb 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://tlseminar.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Certificates</title>
      <link>https://tlseminar.github.io/certificates/</link>
      <pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://tlseminar.github.io/certificates/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;So far, we have learned some real-world TLS attacks and how they bring potential vulnerabiliting in different situations. Since the core SSL/TLS technology has persisted as the basis for securing many aspects of today’s Internet for more than twenty years, including data transfer, user passwords, and site authentication, it is important to also consider issues beyond the protocol.&lt;/p&gt;

&lt;p&gt;This week, we’ll go on to discuss practical issues with TLS including
HTTPS, certificates, key management and an attack called SSLstripping.&lt;/p&gt;

&lt;h1 id=&#34;trust-issues-and-enhancements&#34;&gt;Trust Issues and Enhancements&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://tlseminar.github.io/docs/soktls.pdf&#34;&gt;&lt;em&gt;SoK: SSL and HTTPS: Revisiting past challenges and evaluating certificate trust model enhancements&lt;/em&gt;&lt;/a&gt;, Jeremy Clark and Paul C. van Oorschot, IEEE Symposium on Security and Privacy (&amp;ldquo;Oakland&amp;rdquo;), 2013.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;certificates&#34;&gt;Certificates&lt;/h3&gt;

&lt;p&gt;The TLS protocol enables a client and a server to establish and communicate over a secure channel. Assuming such a secure channel can be created, authenticating the server still remains a challenge. HTTPS attempts to solve this problem using certificates, which bind public keys to servers. Web browsers trust certificates that are issued by certificate authorities (CAs).&lt;/p&gt;

&lt;p&gt;A certificate is bound to a server through its domain name. When requesting a certificate for a domain name from a CA, the requester is challenged to demonstrate control of the domain name. Upon successful validation, the CA will digitally sign a domain validated (DV) certificate for the entity.&lt;/p&gt;

&lt;p&gt;Stronger verification techniques are available due to security issues with hostname validation. A common verification technique used by CAs is to send an email to an email address associated with the domain. This becomes an issue when an attacker is able to spoof DNS records, such as through a DNS cache poisoning attack. Issues may also arise when an attacker is able to register an email address at the domain. For example, an attacker was able to convince a CA that owned &lt;code&gt;login.live.com&lt;/code&gt; by registering &lt;code&gt;sslcertificates@live.com&lt;/code&gt;. In response, CAs offer extended validation (EV) certificates to entities willing to pay a premium and undergo more stringent validation.&lt;/p&gt;

&lt;h3 id=&#34;anchoring-trust&#34;&gt;Anchoring Trust&lt;/h3&gt;

&lt;p&gt;Although anyone can create a certificate for any site they want, clients should only trust a certificate if it has been signed by a CA they already trust. Browsers com pre-configured with a default list of CAs known as trust anchors. Mozilla&amp;rsquo;s Firefox 15 browser includes approximately 150 trust anchors.&lt;/p&gt;

&lt;p&gt;Users may also add additional trust anchors to their system. This is commonly done by organizations in order to MITM their users HTTPS connections to perform content inspection, or by users who want to inspect the contents of their own HTTPS requests.&lt;/p&gt;

&lt;p&gt;Because any trust anchor is able to issue trusted certificates for a website, an adversary need only target the weakest CA in order to obtain a fraudulent certificate. Furthermore, governments are in a position to compel CAs to create valid certificates to be used in MITM attacks.&lt;/p&gt;

&lt;p&gt;To prevent misuse of fraudulent certificates, webservers may use HTTP Public Key Pinning (HPKP) to remember a presented certificate, and warn the user if a different certificate is ever presented for the same domain in the future. This way, even if an adversary has obtained a certificate that is trusted by a browser, they will be unable to perform a MITM attack. However, this technique requires a user to blindly trust the first certificate that the webserver pins. An effective alternative is for browser vendors to include a list of certificates to pin within the browser.&lt;/p&gt;

&lt;h3 id=&#34;transitivity-of-trust&#34;&gt;Transitivity of Trust&lt;/h3&gt;

&lt;p&gt;In addition to signing certificates for webservers, trust anchors can issue certificates allowing other organizations to also act as CAs. While Firefox includes nearly 150 trust anchors from approximately 50 organizations, hundreds of organizations, including the US Department of Homeland Security, are trusted intermediate CAs.&lt;/p&gt;

&lt;p&gt;Client software does not generally maintain a list of intermediate CAs. Rather, they use a chain discovery mechanism to trace a server&amp;rsquo;s certificate back to a trust anchor. Such a chain must be carefully validated to check that each intermediate CA occurring in the chain has actually been granted authority to sign further certificates. This check was previously skipped by Microsoft&amp;rsquo;s CryptoAPI and Apple&amp;rsquo;s iOS.&lt;/p&gt;

&lt;p&gt;One way to ensure that every intermediate CA is visible to users is to publish a list of every valid certificate. This way, clients are able to know about intermediate CAs before their certificate is encountered. This is important because intermediate CAs can have just as much power as the trust anchors.&lt;/p&gt;

&lt;h3 id=&#34;maintenance-of-trust-revocation&#34;&gt;Maintenance of Trust (Revocation)&lt;/h3&gt;

&lt;p&gt;Sometimes a certificate needs to be revoked, such as when a site is compromised or abandoned, the domain name is exchanged, or the CA becomes aware of mistaken issuance. This revocation status must be readily available through the CA, either through a certificate revocation list (CRL) or an online certificate status checking protocol (OCSP).&lt;/p&gt;

&lt;p&gt;Because this revocation information may be unavailable, browsers choose to accept certificates when the information cannot be located. Thus an adversary who is able to prevent a browser from obtaining revocation information may be able to cause a revoked certificate to be accepted.&lt;/p&gt;

&lt;p&gt;Besides the list of all valid certificates described above, one way to combat unreliable revocation is for webservers to provide timestamped OCSP status reports, a technique known as Certificate Status Stapling. Alternatively, if certificates were issued to be valid for a shorter time, the impact of missing a revocation is lessened. Currently, certificates are often valid for years, but a 2012 proposal calls for certificates that remain valid for only four days, eliminating the need for a revocation mechanism (&lt;a href=&#34;http://www.w2spconf.com/2012/papers/w2sp12-final9.pdf&#34;&gt;Topalovic et al.&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;indication-and-interpretation-of-trust&#34;&gt;Indication and Interpretation of Trust&lt;/h3&gt;

&lt;p&gt;When a user browses to a website, they are expected to verify that they are connecting over HTTPS. This is indicated to the users through the &lt;code&gt;https://&lt;/code&gt; at the beginning of the URL in the address bar, and the green lock icon displayed by the browser. This icon may typically be clicked on to display more information about the website&amp;rsquo;s certificate. However, studies have shown that many users do not look for these indicators, and may even assume a page is secure based on the type of information being displayed.&lt;/p&gt;

&lt;p&gt;Even when a browser displays a warning for a failed HTTPS connection, many users will click through and still log into the site. This may be due to users not understanding the certificate warning, not understanding the risks of visiting a site with an invalid certificate, or making a decision to visit the site anyway despite understanding and weighing the rists. Another common warning is the mixed scripting warnings, indicating that Javascript is being loaded over plain HTTP but being run within the HTTPS site&amp;rsquo;s privileges.&lt;/p&gt;

&lt;p&gt;If an adversary expects a user to look for HTTPS indicators, they may be able to spoof common security cues. Some users believe an image of a lock on the website is a sign of a successful HTTPS connections. A more involved example is shown in the image below, where an attacker has simulated a browser address bar, complete with the HTTPS indicators that come with a valid EV certificate.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img width=594 alt=&#34;Security Indicators&#34; src=&#34;https://tlseminar.github.io/images/TSS2.png&#34;&gt;&lt;Br&gt;
Fake Address Bar (Image from &lt;a href=&#34;https://blog.malwarebytes.com/cybercrime/social-engineering-cybercrime/2016/08/tech-support-scams-and-google-chrome-tricks/&#34;&gt;Malwarebytes&lt;/a&gt;)
&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;coniks-and-certificate-transparency&#34;&gt;CONIKS and Certificate Transparency&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://eprint.iacr.org/2014/1004.pdf&#34;&gt;CONIKS: Bringing Key Transparency to End Users&lt;/a&gt;&lt;/strong&gt;, Marcela S. Melara, Aaron Blankstein, Joseph Bonneau, Edward W. Felten, Michael J. Freedman, USENIX Security &amp;lsquo;15&lt;/p&gt;

&lt;p&gt;CONIKS is a key management system intended to reduce the workload on clients to verify keys for secure communications. It&amp;rsquo;s an extension of the existing certificate transparency logs for webservers to end users. CONIKS simultaneously helps address the issue of service providers tampering with keys and of trust establishment that would otherwise be done out-of-band manually. The system is intended to prevent equivocation of keys, prevent the addition of unauthorized keys, and allow for transparent and public verification all while being efficient for users.&lt;/p&gt;

&lt;p&gt;CONIKS is motivated by a desire to increase the use of end-to-end encryption, which has traditionally struggled with key management. Systems like WhatsApp and Apple&amp;rsquo;s iMessage use centralized storage of public keys which is vulnerable to key removal, key changing, or server takeover. Furthermore, many systems have no way (beyond clunky manual steps) to verify contacts are who they claim to be.&lt;/p&gt;

&lt;h3 id=&#34;design&#34;&gt;Design&lt;/h3&gt;

&lt;p&gt;The design of CONIKS involves several non-distinct participants: service providers, end users, and auditors. &lt;em&gt;Service providers&lt;/em&gt; manage their own individual namespace of name (e.g., &lt;code&gt;alice@host.com&lt;/code&gt;) to key bindings. While not assumed to be trustworthy, service providers are expected to have a reputation to uphold. &lt;em&gt;End-users&lt;/em&gt; are the clients and intend to communicate with each other securely. Clients require only a relatively accurate clock and a usable network connection. They are also responsible for serving as &lt;em&gt;auditors&lt;/em&gt; who track the key log for forgeries, invalid updates, and new unsolicited keys.&lt;/p&gt;

&lt;p&gt;Each service provider constructs its directory of &lt;em&gt;name&lt;/em&gt; &amp;rarr; &lt;em&gt;key&lt;/em&gt; mappings as a Merkle binary prefix tree, with each tree node representing a unique prefix.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://tlseminar.github.io/images/merkle.png&#34; width=500 alt=&#34;Merkle Tree&#34;&gt;&lt;/img&gt;&lt;br&gt;
Merkle Prefix tree (image from CONIKS paper
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;As in other Merkle trees, interior nodes represent hashes of their left and right children. Leaf nodes are hashed over a nonce (&lt;em&gt;k&lt;sub&gt;n&lt;/em&gt;&lt;/sub&gt;), a node index, the tree depth, and a cryptographic commitment of the user&amp;rsquo;s name and public key. Empty or placeholder nodes are hashed similarly, but instead include a different constant, &lt;em&gt;k&lt;sub&gt;empty&lt;/sub&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://tlseminar.github.io/images/strchain.png&#34; width=&#34;650&#34; alg=&#34;STR Chain&#34;&gt;&lt;br&gt;
Signed STR chain (Image from CONIKS paper)
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;At regular intervals, or epochs, the service provider signs the merkle root of the previous tree and a sequentially increasing number to indicate the order of the blocks. This helps ensure that service providers cannot change the historical record easily, and also must maintain a changed STR chain indefinitely.&lt;/p&gt;

&lt;h3 id=&#34;common-operations&#34;&gt;Common Operations&lt;/h3&gt;

&lt;p&gt;Registration in a CONIKS system occurs when the user sends their name and public key to the service provider. Since the server only published a signed record every epoch, it will issue a &amp;ldquo;temporary binding&amp;rdquo; in the mean-time to validate the key, signing the user key, name, and eventual index.&lt;/p&gt;

&lt;p&gt;To look up a key, clients will consult the server for a given name and receive the matching public key and a STS proof of inclusion, consisting of all the hashes from the position of the key on the way up the tree. Since interior nodes consist only of hashes of the left and right nodes, the client can verify that the key is at the position the server claims, or that the key is truly missing if the server claims it is.&lt;/p&gt;

&lt;p&gt;A general flow for secure communications therefore looks something like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Alice contacts the service provider (Carol) and requests the public key for &lt;code&gt;bob@host.com&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Carol returns the public key and the proof of inclusion hash chain.&lt;/li&gt;
&lt;li&gt;Alice computes the merkle root of the tree and compares to her last known root from the STR chain.&lt;/li&gt;
&lt;li&gt;After proving Carol gave the correct key, Alice encrypts her message with Bob&amp;rsquo;s public key and sends it.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;auditing&#34;&gt;Auditing&lt;/h3&gt;

&lt;p&gt;One of the most important features of CONIKS is the ability for anyone to audit the &lt;em&gt;name&lt;/em&gt; &amp;rarr; &lt;em&gt;key&lt;/em&gt; mappings. Indeed, clients are encouraged to regularly audit their own keys to ensure they have not been compromised. Auditing works much like key lookup &amp;mdash; the server is consulted for the key mapping to the given name. Clients who are also auditing will confirm that the returned private key matches the saved one they possess, and that the keys have not changed in an authorized way between epochs.&lt;/p&gt;

&lt;h3 id=&#34;considerations-for-deploying-coniks&#34;&gt;Considerations for deploying CONIKS&lt;/h3&gt;

&lt;h4 id=&#34;initial-key-submission-window&#34;&gt;Initial key submission window&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s important to note that until the next STR is published, clients won&amp;rsquo;t be able to communicate using their public key, as nobody else will have seen it. However, clients can audit their own keys to prevent any malicious actors from changing their initial key upload.&lt;/p&gt;

&lt;h4 id=&#34;whistleblowing&#34;&gt;&amp;lsquo;Whistleblowing&amp;rsquo;&lt;/h4&gt;

&lt;p&gt;The CONIKS protocol currently doesn&amp;rsquo;t provide any way for clients to contact each other if they detect malicious activity either in general or on the part of the service provider. If their keys are hijacked, they are responsible for communicating that information to others on their own, which could be over an unsafe channel.&lt;/p&gt;

&lt;h4 id=&#34;key-change-or-revocation&#34;&gt;Key Change or Revocation&lt;/h4&gt;

&lt;p&gt;CONIKS doesn&amp;rsquo;t currently provide any way for users to update or revoke their keys directly. One easy path would be for users to sign some message indicating they wish to remove the previous key. However, if a user lost their key they would be unable to revoke their old one.&lt;/p&gt;

&lt;h1 id=&#34;ssl-stripping&#34;&gt;SSL Stripping&lt;/h1&gt;

&lt;h5 id=&#34;defeating-ssl-using-sslstrip-https-www-youtube-com-watch-v-mfol6imbz7y-2009-black-hat-dc-presentation-by-moxie-marlinspike&#34;&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=MFol6IMbZ7Y&#34;&gt;Defeating SSL Using sslstrip&lt;/a&gt; 2009 Black Hat DC presentation by Moxie Marlinspike&lt;/h5&gt;

&lt;p&gt;In this part of the blog post we further explore the sslstrip attack, presented to the class by Team Sesame on February 10th, 2017.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img width=&#34;500&#34; alt=&#34;MITM Framework&#34; src=&#34;https://tlseminar.github.io/images/sslstrip.png&#34;&gt;&lt;br&gt;
In-the-Middle Attack Setup (Image from avicoder)
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;The sslstrip attack is both an in-the-middle attack and protocol downgrade attack that relies on websites not implementing HSTS and also browsers&amp;rsquo; inability to prevent users from POST&amp;rsquo;ing sensitive data to HTTP websites.&lt;/p&gt;

&lt;p&gt;The sslstrip python module, when used in conjunction with an MITM framework, replies to the victim&amp;rsquo;s HTTPS requests with HTTP versions of the same page silently stripping the &lt;code&gt;S&lt;/code&gt;. On modern browsers the only visual cue is the lack of HTTPS:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://tlseminar.github.io/images/sslstripindicator.png&#34; width=&#34;400&#34;&gt;&lt;br&gt;
Screenshot of Chrome on iPhone 7
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;This differs from other HTTPS MITM attacks whereby an attacker forces the victim to connect to a fake access point where tools like mitmproxy can be then used to sign forged certificates for websites on the fly.&lt;/p&gt;

&lt;p&gt;However, most browsers have mechanisms to protect against this like HTTP Public Key Pinning (HPKP) and browser warnings:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://tlseminar.github.io/images/chromenotprivate.png&#34; width=&#34;400&#34; alt=&#34;Chrome: Not Private&#34;&gt;&lt;br&gt;
Self signed SSL certificate warning in Google Chrome, image courtesy of &lt;a href=&#34;http://www.inmotionhosting.com/support/website/ssl/self-signed-ssl-certificate-warning&#34;&gt;Inmotionhosting&lt;/a&gt;.
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;necessary-requirements&#34;&gt;Necessary Requirements&lt;/h3&gt;

&lt;p&gt;In order for an attacker to obtain victim credentials for a given HTTPS website using sslstrip&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The attacker must be on the same LAN as the victim (necessary to obtain MITM status)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The HTTPS website the victim accesses must have initiated the connection first via HTTP&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The given website must not be on victim&amp;rsquo;s browsers HSTS Preloads (supported by all modern browsers, this list includes the Google domains and ~7500 other sites)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sslstrip works by listening for HTTP 301 “Moved Permanently&amp;rdquo; (i.e., Redirect to HTTPS). So unless the victim explicitly types in https:// (HTTPS to begin with) or the website is on the browser&amp;rsquo;s HSTS Preloads, or the website is HTTPS only, the 301 will be issued and at that point sslstrip will intercept this response and instead relay back to the victim a HTTP version of the HTTPS site.&lt;/p&gt;

&lt;p&gt;So, Requirement 2 is necessary for sslstrip to work. In the case of the website being on the browser list of HSTS preloads, then the first request over HTTPS is is never dispatched but rather internally redirected by the browser to the HTTPS version which is why Requirement 3 states the given website must not be on the &lt;a href=&#34;https://chromium.googlesource.com/chromium/src/+/master/net/http/transport_security_state_static.json&#34;&gt;HSTS Preload list&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;countermeasures&#34;&gt;Countermeasures&lt;/h3&gt;

&lt;p&gt;The most obvious countermeasures include:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Browser Indications, SSLight, other addons?&lt;/li&gt;
&lt;li&gt;Server: HSTS (HTTP Strict Transport Security) Preloads&lt;/li&gt;
&lt;li&gt;Server: HTTPS only&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While improvements have been made to sslstrip such as using different domains like &lt;code&gt;wwww&lt;/code&gt; (and various countermeasures like key pinning and browser displays), in present day the original sslstrip (2009) does not work against sites with HSTS enabled like &lt;code&gt;facebook.com&lt;/code&gt; and &lt;code&gt;gmail.com&lt;/code&gt;. Surprisingly though, a &lt;a href=&#34;https://news.netcraft.com/archives/2016/03/17/95-of-https-servers-vulnerable-to-trivial-mitm-attacks.html&#34;&gt;2016 article&lt;/a&gt; claimed only 1 in 20 HTTPS servers implemented HSTS correctly!&lt;/p&gt;

&lt;p&gt;Sslstrip is an easily-deployable and effective attack &amp;ldquo;in the wild&amp;rdquo; because of but not limited to session hijacking and the fact most browsers do not alert users they are submitting over http (or conversely most users do not notice &lt;code&gt;http://&lt;/code&gt; when submitting sensitive info). In addition, password reuse is widespread and if credentials were obtained from say apple.com or a bank they could be tried against more sensitive websites which do support HSTS (enable two factor authentication!!).&lt;/p&gt;

&lt;h3 id=&#34;further-reading&#34;&gt;Further Reading:&lt;/h3&gt;

&lt;p&gt;Writeup describing modern browser and website protections against MITM attacks:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.troyhunt.com/understanding-http-strict-transport/&#34;&gt;https://www.troyhunt.com/understanding-http-strict-transport/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Try it out yourself! This blog post describes how an attacker on Mac OS X could use sslstrip to gather credentials over network. I learned both my online banking website and apple.com were vulnerable to sslstrip (i.e. the domains of these sites were not on my browsers HSTS preload list).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://techjots.blogspot.com/2012/11/sslstrip-on-mac-os-x-mountain-lion.html&#34;&gt;http://techjots.blogspot.com/2012/11/sslstrip-on-mac-os-x-mountain-lion.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Downgrade Attacks</title>
      <link>https://tlseminar.github.io/downgrade-attacks/</link>
      <pubDate>Fri, 03 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://tlseminar.github.io/downgrade-attacks/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;TODO: add a short overview paragraph, giving a roadmap (with links to later sections) to the whole story&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;diffie-hellman-cryptanalysis&#34;&gt;Diffie-Hellman Cryptanalysis&lt;/h1&gt;

&lt;p&gt;Diffie-Hellman is a cryptologic method used to confidentially generate a shared secret (encryption key) between two parties in a conversation.  Because the shared secret is used to encrypt message traffic, the integrity of Diffie-Hellman is crucial to the security of TLS, where the confidentiality of communication depends heavily on the process of securely generating a shared encryption key.&lt;/p&gt;

&lt;h2 id=&#34;background-diffie-hellman-key-exchange&#34;&gt;Background: Diffie-Hellman Key Exchange&lt;/h2&gt;

&lt;p&gt;The genius of Diffie-Hellman lies in its adherence to the principle of perfect forward secrecy.  The asymmetric keys used to perform the key exchange can be deleted after the key exchange is completed, so there is no risk of a later compromise enabling an attacker to break previous traffic.  The agreed shared key is never transmitted, saved, or otherwise made observable across a communication channel, even if the adversary were to collect all encrypted data in transit and recover all material stored at the endpoints, it would still not be able to break the encryption.&lt;/p&gt;

&lt;p&gt;The mathematical underpinnings of Diffie-Hellman are relatively simple.  See the following image for an illustration of the exchange that occurs when generating a shared secret.  Note that the secret values, &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, are never transmitted nor shared between Alice and Bob.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://i.stack.imgur.com/uYqQe.png&#34; alt=&#34;Alt&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;sup&gt;Image Source:  &lt;a href=&#34;https://i.stack.imgur.com/uYqQe.png&#34;&gt;https://i.stack.imgur.com/uYqQe.png&lt;/a&gt; &lt;/sup&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-diffie-hellman-problem&#34;&gt;The Diffie-Hellman Problem&lt;/h2&gt;

&lt;p&gt;The Diffie-Hellman problem (DHP) is as follows:  Given an element \(g\) and the values \(g^x, g^y\) what is the value of \(g^{xy}\)?&lt;/p&gt;

&lt;p&gt;Clearly, if this problem were easy to solve, Diffie-Hellman would be useless, since any eavesdropping adversary could then collect both \(g^x\) and \(g^y\), compute \(g^{xy}\), and subsequently decrypt all of Alice and Bob’s communication.  The Discrete Logarithm Problem (DLP) is thus by far the most efficient means to solve DHP and requires that the eavesdropping adversary compute \(x\) given \(g\) and \(g^x\) – still believed to be a hard problem in general.  But, if \(p\) is a weak prime (as explained below), it can solved in a reasonable amount of time with available computing resources.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TODO: Add a link to paper&lt;/strong&gt; Adrian et al. published a paper in 2015 that demonstrated a weakness in Diffie-Hellman key exchange in the Handshake Protocol of TLS. In order to perform cryptanalysis in such a situation, an attacker must solve DLP by computing arbitrary discrete log values in real-time. While it is not known how to calculate discrete logs efficiently (and believed to be hard), the attack can be accelerated using precomputation.&lt;/p&gt;

&lt;h2 id=&#34;index-calculus&#34;&gt;Index Calculus&lt;/h2&gt;

&lt;p&gt;While the logic behind the precomputation cryptanalysis is based on the General Number Field Sieve, we examine Index Calculus, a simplified version of the same concept. Index Calculus involves two steps: sieving and linear algebra. In the sieving step, the cryptanalyst chooses a multiplicative group of numbers and attempts to find numbers that factor completely over this group. We can then express these numbers as linear combinations of logs of the multiplicative group elements. By finding many such numbers, we obtain equations in terms of logs of multiplicative group elements. In the linear algebra step, we can use these equations to solve for values of the logs. This allows us to generate a database of precomputed logs.&lt;/p&gt;

&lt;h2 id=&#34;active-downgrade&#34;&gt;Active Downgrade&lt;/h2&gt;

&lt;p&gt;Using precomputed discrete logs, an attacker can perform an active downgrade attack on a TLS connection. Operating as an in-the-middle attacker, the attacker intercepts a Client Hello message and alters it to instruct the server to use export-grade Diffie-Hellman, which uses 512-bit keys rather than 1024-bit or higher, which allows the attacker to use the precomputed logs. During the Handshake Protocol, the attacker is able to solve the discrete log problem and recover the master secret of that connection. This allows the attacker to communicate directly with the client over an encrypted channel, while the client still thinks he/she is communicating with their intended server.&lt;/p&gt;

&lt;h2 id=&#34;the-logjam-attack-step-by-step&#34;&gt;The Logjam Attack:  Step-by-Step&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://cryptologie.net/upload/logjam.png&#34; alt=&#34;Alt&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;sup&gt;&lt;a href=&#34;https://cryptologie.net/upload/logjam.png&#34;&gt;https://cryptologie.net/upload/logjam.png&lt;/a&gt;&lt;/sup&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The Client sends a &lt;code&gt;Client Hello&lt;/code&gt; message to the Server.  This includes a list of all supported ciphersuites that can be used to generate the shared secret and requests that one be selected by the Server to begin the Diffie-Hellman exchange.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The adversary intercepts the &lt;code&gt;Client Hello&lt;/code&gt; messages and alters the available ciphersuites to only include 512-bit Diffie-Hellman, then forwards the altered Client Hello to the Server.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The Server receives the &lt;code&gt;Client Hello&lt;/code&gt;.  Since only one ciphersuite is shown to be supported by the Client, the Server agrees to 512-bit Diffie-Hellman and generates a 512-bit prime \(p\) to be used in the key exchange.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The adversary intercepts the ciphersuite confirmation message from the Server and alters it to reflect the client’s original ciphersuite preference, selecting full-strength DHE.  It also eavesdrops on the Server’s Diffie-Hellman communication to discern \(g\) and \(gb\).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The Client thinks it has received the proper Diffie-Hellman information from the Server and begins its half of the Diffie-Hellman exchange.  Note that the 512-bit prime \(p\) is still considered a valid prime for 1024-bit DHE. Meanwhile, the adversary is hard at work calculating the discrete log of \(g^b \mod p_{512}\). Multiple factors can contribute to reduce the time-complexity of this process.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once the adversary has determined the value of \(b\), the Client and adversary begin communicating as though the adversary is the Server.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The time-complexity of precomputation using the number field sieve is entirely dependent on the prime number used; as a result, any connections using the same prime can be quickly broken.  The researchers behind Logjam detected that millions of HTTPS, SSH, and VPN servers use the same prime numbers for Diffie-Hellman key exchange, rendering supposedly-secure communications vulnerable to Logjam.&lt;/p&gt;

&lt;h2 id=&#34;weak-primes&#34;&gt;Weak Primes&lt;/h2&gt;

&lt;p&gt;Consider a prime number \(p\).  In 1978, Pohlig and Hellman demonstrated that if all factors of \(p-1\) are less than \(\log^c p\), the problem of solving the discrete logarithm \(\mod p\) is in \(P\).  In general terms, this means an attacker can greatly reduce the complexity of the discrete logarithm problem and thus conduct the Logjam attack in a shorter period of time.  We&amp;rsquo;ll demonstrate with an example using a small prime.&lt;/p&gt;

&lt;p&gt;Let \(p = 31\) and \(g = 3\).  \(g\) has order 30 → \(g^{30} = 1 \mod p\)&lt;/p&gt;

&lt;p&gt;The factors of \(30 = 2 * 3 * 5\) are too small for the prime \(p\) to be secure, allowing an attacker to convert the discrete logarithm problem \(\mod 31\) into problems \(\mod 2, 3, 5\).  With the help of the Chinese Remainder Theorem, an attacker can easily find \(x\) given \(g\) and \(g^x\).&lt;/p&gt;

&lt;p&gt;A strong prime \(p = 2q + 1\) (\(q\) is prime) avoids this problem of reducibility by ensuring that \((p-1)\div 2\) cannot be composite (and, by extension, that Pohlig-Hellman cannot obtain information from \(p\)).&lt;/p&gt;

&lt;p&gt;This puts a server that supports export-grade DH and reuses weak primes at severe risk to a motivated attack.&lt;/p&gt;

&lt;h1 id=&#34;bleichenbacher-s-padding-oracle-attack&#34;&gt;Bleichenbacher’s Padding Oracle Attack&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://archiv.infsec.ethz.ch/education/fs08/secsem/Bleichenbacher98.pdf&#34;&gt;Bleichenbacher’s padding oracle attack&lt;/a&gt;  is an adaptive chosen ciphertext attack against PKCS#1 v1.5, the RSA padding standard used in SSL and TLS. It enables decryption of RSA ciphertexts if a server distinguishes between correctly and incorrectly padded RSA plaintexts, and was termed the “million-message attack” upon its introduction in 1998, after the number of decryption queries needed to deduce a plaintext. All widely used SSL/TLS servers include countermeasures against Bleichenbacher attacks.&lt;/p&gt;

&lt;h2 id=&#34;pkcs-1-v1-5-encryption-padding&#34;&gt;PKCS#1 v1.5 encryption padding&lt;/h2&gt;

&lt;p&gt;Bleichenbacher’s padding oracle attack relies on the structure of &lt;a href=&#34;https://tools.ietf.org/html/rfc2313&#34;&gt;RSA PKCS#1 v1.5 padding&lt;/a&gt;. Although RSA PKCS#1 v2.0 implements OAEP, SSL/TLS still uses PKCS#1 v1.5. The PKCS#1 v1.5 encryption padding scheme randomizes encryptions by prepending a random padding string PS to a message &lt;em&gt;k&lt;/em&gt; (here, a symmetric session key) before RSA encryption:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The plaintext message is &lt;em&gt;k&lt;/em&gt;, \(l_k = |k|\).
The encrypter generates a random byte string PS,
where |PS| ≥ 8, \(|PS| = l_m − 3 − l_k \) and &lt;code&gt;0x00&lt;/code&gt; \( \notin{PS[1],&amp;hellip;,PS[|PS|]}\)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The encryption block is \(m =\) &lt;code&gt;00&lt;/code&gt; || &lt;code&gt;02&lt;/code&gt; || \(PS\) || &lt;code&gt;00&lt;/code&gt; || \(k\)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The ciphertext is computed as \(c = m^e\mod{N}\).
To decrypt such a ciphertext, the decrypter first computes \(m = c^d \mod{N}\). Then it checks whether the decrypted message m is correctly formatted as a PKCS#1 v1.5-encoded message. We say that the ciphertext c and the decrypted message bytes \(m[1]||m[2]||&amp;hellip;||m[l_m]\) are PKCS#1 v1.5 conformant if:&lt;/p&gt;

&lt;p&gt;\( \qquad m[1] || m[2] = \) &lt;code&gt;0x00&lt;/code&gt; || &lt;code&gt;0x02&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; \(\notin {m[3],&amp;hellip;,m[10]} \)&lt;/p&gt;

&lt;p&gt;If this condition holds, the decrypter searches for the first value &lt;em&gt;i&lt;/em&gt; &amp;gt; 10 such that \(m[i] =\) &lt;code&gt;0x00&lt;/code&gt;. Then, it extracts \(k = m[i+1]||&amp;hellip;||m[l_m]\). Otherwise, the ciphertext is rejected.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In SSLv3 and TLS, RSA PKCS#1 v1.5 is used to encapsulate the premaster secret exchanged during the handshake. Thus, &lt;em&gt;k&lt;/em&gt; is interpreted as the premaster secret. In SSLv2, RSA PKCS#1 v1.5 is used for encapsulation of an equivalent key denoted the &lt;em&gt;master_key&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;bleichenbacher-attack&#34;&gt;Bleichenbacher attack&lt;/h2&gt;

&lt;p&gt;Bleichenbacher’s attack is a padding oracle attack; it exploits the fact that RSA ciphertexts should decrypt to PKCS#1 v1.5-compliant plaintexts. If an implementation receives an RSA ciphertext that decrypts to an invalid PKCS#1 v1.5 plaintext, it might naturally leak this information via an error message, by closing the connection, or by taking longer to process the error condition. This behavior can leak information about the plaintext that can be modeled as a cryptographic oracle for the decryption process. Bleichenbacher demonstrated how such an oracle could be exploited to decrypt RSA ciphertexts.&lt;/p&gt;

&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;

&lt;p&gt;In the simplest attack scenario, the attacker has a valid PKCS#1 v1.5 ciphertext \(c_0\) that they wish to decrypt to discover the message m0. They have no access to the private RSA key, but instead have access to an oracle, \(\delta\), that will decrypt a ciphertext &lt;em&gt;c&lt;/em&gt; and inform the attacker whether the most significant two bytes match the required value for a correct PKCS#1 v1.5 padding:&lt;br /&gt;
&lt;center&gt;
\( \delta (c) = 1 \) if  \(m = c^d \mod{N} \) starts with &lt;code&gt;0x00~02 0&lt;/code&gt;
$$ \delta (c) = 0 \textrm{ otherwise}.$$
&lt;/center&gt;
If the oracle answers with 1, the attacker knows that \(2B ≤ m ≤ 3B−1\), where \(B = 2^{8(l_m−2)}\).&lt;/p&gt;

&lt;p&gt;The attacker can take advantage of RSA malleability to generate new candidate
ciphertexts for any s:&lt;/p&gt;

&lt;p&gt;$$c = (c_0 · s_e)\mod{N} = {m_0 ·s}^e \mod{N}$$&lt;/p&gt;

&lt;p&gt;The attacker queries the oracle with &lt;em&gt;c&lt;/em&gt;. If the oracle responds with 0, the attacker increments &lt;em&gt;s&lt;/em&gt; and repeats the previous step. Otherwise, the attacker learns that for some &lt;em&gt;r&lt;/em&gt;, \(2B ≤ m_{0}s−rN &amp;lt; 3B\). This allows the attacker to reduce the range of possible solutions to:&lt;/p&gt;

&lt;p&gt;$$ \frac{2B+rN}{s} ≤ m_0 &amp;lt; \frac{3B+rN}{s} $$&lt;/p&gt;

&lt;p&gt;The attacker proceeds by refining guesses for &lt;em&gt;s&lt;/em&gt; and &lt;em&gt;r&lt;/em&gt; values and successively decreasing the size of the interval containing \(m_0\). At some point the interval will contain a single valid value, \(m_0\). &lt;a href=&#34;**TODO: link**&#34;&gt;Bleichenbacher’s original paper&lt;/a&gt; describes this process in further detail.&lt;/p&gt;

&lt;p&gt;It is worth noting that the author implemented a proof-of-concept of this attack on a custom padding oracle implementation. Over a test set of various 512-bit and 1024-bit keys, between 300,000 and 2 million ciphertexts were required to find the message. While the details of the custom oracle are not known, it is reasonable to assume that this attack is feasible in more realistic scenarios.&lt;/p&gt;

&lt;h2 id=&#34;countermeasures&#34;&gt;Countermeasures&lt;/h2&gt;

&lt;p&gt;In order to protect against this attack, the reciever must not leak information about the PKCS#1 v1.5 validity of the ciphertext. The ciphertext does not decrypt to a valid message, so the decrypter generates a fake plaintext and continues the protocol with this decoy. The attacker should not be able to distinguish the resulting computation from a correctly decrypted ciphertext.  In the case of SSL/TLS, the server generates a random premaster secret to continue the handshake if the decrypted ciphertext is invalid. The client will not possess the session key to send a valid ClientFinished message and the connection will terminate.&lt;/p&gt;

&lt;p&gt;In addition, newer versions of &lt;a href=&#34;https://tools.ietf.org/html/rfc3447&#34;&gt;PKSC#1&lt;/a&gt; describe a new padding type, called OAEP, which uses hash function to add more internal redundancy. This greatly decreases the probability that random strings will result in valid padding, effectively preventing the attack.&lt;/p&gt;

&lt;h2 id=&#34;sources&#34;&gt;Sources&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;TODO: make the papers have links to actual papers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/duesee/bleichenbacher/blob/master/main.py&#34;&gt;https://github.com/duesee/bleichenbacher/blob/master/main.py&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://secgroup.dais.unive.it/wp-content/uploads/2012/11/Practical-Padding-Oracle-Attacks-on-RSA.html&#34;&gt;http://secgroup.dais.unive.it/wp-content/uploads/2012/11/Practical-Padding-Oracle-Attacks-on-RSA.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://cryptopals.com/sets/6/challenges/47&#34;&gt;https://cryptopals.com/sets/6/challenges/47&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;D. Bleichenbacher. Chosen ciphertext attacks against protocols based on the RSA encryption standard. In Advances in Cryptology: Proceedings of CRYPTO ’98, volume 1462 of LNCS, pages 1–12, 1998.&lt;/p&gt;

&lt;p&gt;Bardou, R., Focardi, R., Kawamoto, Y., Simionato, L., Steel, G., AND Tsay, J.-K. Efficient padding oracle attacks on cryptographic hardware. In Advances in Cryptology–CRYPTO 2012. Springer, 2012, pp. 608–625.&lt;/p&gt;

&lt;p&gt;N. Aviram S. Schinzel J. Somorovsky N. Heninger M. Dankel J. Steube L. Valenta D. Adrian J. A. Halderman V. Dukhovni E. Kasper S. Cohney S. Engels C. Paar Y. Shavitt &amp;ldquo;DROWN: Breaking TLS with SSLv2&amp;rdquo; Mar. 2016 [online] Available: &lt;a href=&#34;https://drownattack.com/&#34;&gt;https://drownattack.com/&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;drown-breaking-tls-using-sslv2&#34;&gt;DROWN: Breaking TLS using SSLv2&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://tlseminar.github.io/docs/drown.pdf&#34;&gt;Paper Link&lt;/a&gt;
| &lt;a href=&#34;https://drownattack.com/&#34;&gt;Website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;DROWN attack is inspired by &lt;a href=&#34;#bleichenbacher-attack&#34;&gt;Bleichenbacher’s padding oracle attack&lt;/a&gt; over SSLv2 which could decrypt an SSLv2 RSA ciphertext. The attack was possible due to a flaw in SSLv2 protocol which revealed if the decrypted message was conformant with PKCS#1 v1.5 padding or not, thus acting as a &lt;a href=&#34;https://tlseminar.github.io/padding-oracle/&#34;&gt;padding oracle&lt;/a&gt;. The padding scheme is shown below where first two bytes are fixed &lt;code&gt;0x00 0x02&lt;/code&gt; followed by 8 bytes of random padding string succeeded by a &lt;code&gt;0x00&lt;/code&gt; byte. The remaining part of the message is the plaintext which may contain the key to be recovered. The padding scheme is shown below:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/downgrade-attacks/pkcs1padding.png&#34; alt=&#34;PKCSPadding&#34; style=&#34;width:500px;&#34;/&gt;&lt;br&gt;
&lt;sup&gt;PKCS#1 v1.5 Padding Scheme &lt;/sup&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;The client in SSLv2 protocol sends ClientMasterKey message to SSLv2 server which the server decrypts and responds with ServerVerify message which tells whether the ClientMasterKey message was conformant with the padding scheme.&lt;/p&gt;

&lt;p&gt;The figure below depicts the SSLv2 protocol. The attacker can modify the original ClientMasterKey message and if the SSLv2 server confirms the padding, the attacker would immediately get to know that the first two bytes of the modified message is ‘0x00 0x02’. This way, the attacker can repeatedly modify the original message and query the oracle. After multiple successful guesses for modified message, the attacker can narrow down the guesses for the original message and recover the &lt;em&gt;master_key&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/downgrade-attacks/sslv2flaw.png&#34; alt=&#34;SSLv2Flaw&#34; style=&#34;width:500px;&#34;/&gt;&lt;br&gt;
&lt;sup&gt;Flaw in SSLv2 protocol where the server reveals the correctness of padding &lt;br&gt;
Source: &lt;a href=&#34;https://tlseminar.github.io/docs/drown.pdf&#34;&gt;https://tlseminar.github.io/docs/drown.pdf&lt;/a&gt;&lt;/sup&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Moreover, SSLv2 allowed export-grade ciphersuites which supported 40-bit key. A Bleichenbacher attacker could brute-force the key by repeatedly querying the SSLv2 server.&lt;/p&gt;

&lt;p&gt;TLS patched the above flaws and (most) servers made the SSLv2 protocol obsolete. However, it was not uncommon for TLS servers to share same RSA keys with SSLv2 servers. This made the TLS servers vulnerable to a modified form of Bleichenbacher attack which uses a SSLv2 server as padding oracle to decrypt the shared RSA key. DROWN instantiated this protocol-level attack and decrypted a TLS 1.2 handshake using 2048-bit RSA in 8 hours at a cost of $440 on Amazon EC2. As if this wasn&amp;rsquo;t devastating enough, the authors of DROWN pointed out some implementation bugs in OpenSSL which lead to another attack called Special DROWN that could decrypt a TLS ciphertext in under 1 minute using a single CPU. Both the attacks are described below.&lt;/p&gt;

&lt;h2 id=&#34;drown-attack&#34;&gt;DROWN Attack&lt;/h2&gt;

&lt;p&gt;DROWN attack requires that a TLS server and a SSLv2 server share an RSA key. The attacker records multiple TLS handshake messages between a client and the TLS server. The aim of the attacker is to decrypt the RSA key of the TLS handshake. To do so, the attacker forces the client to establish a connection with an SSLv2 server having the same RSA key so that the attacker can initiate the Bleichenbacher attack to recover the RSA key.&lt;/p&gt;

&lt;p&gt;Now the main hurdle for the attacker is that the format of TLS handshake message may not comply with PKCS#1 v1.5 padding scheme of SSLv2. The attacker converts the TLS ciphertext to SSLv2 ciphertext using the concept of trimmers introduced by &lt;a href=&#34;https://hal.inria.fr/hal-00691958/document&#34;&gt;Bardou et al.&lt;/a&gt; which reduces the size of the TLS message. The use of trimmers require repeated querying to SSLv2 server by shifting the message bytes. The recovered SSLv2 plaintext is then converted back to TLS plaintext which reveals the RSA key of TLS handshake.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/downgrade-attacks/drownattack.png&#34; alt=&#34;DROWN&#34; style=&#34;width:500px;&#34;/&gt;&lt;br&gt;
&lt;sup&gt;SSLv2-based Bleichenbacher attack on TLS &lt;br&gt;
Source: &lt;a href=&#34;https://tlseminar.github.io/docs/drown.pdf&#34;&gt;https://tlseminar.github.io/docs/drown.pdf&lt;/a&gt;&lt;/sup&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;special-drown-attack&#34;&gt;Special DROWN Attack&lt;/h2&gt;

&lt;p&gt;The OpenSSL implementation had two bugs which led to a more efficient Bleichenbacher attack on an OpenSSL implementation of SSLv2 server.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;OpenSSL extra clear oracle:&lt;/b&gt; OpenSSL implementation allowed non-export cipher messages to contain &lt;em&gt;clear_key_data&lt;/em&gt; which lead to potential overwriting of key bytes with null bytes. An attacker could vary the number of null bytes to decrypt the whole key one byte at a time.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;OpenSSL leaky export oracle:&lt;/b&gt; OpenSSL in export cipher mode allowed valid oracle response for correctly padded message of ‘any’ length.&lt;/p&gt;

&lt;p&gt;These bugs remained in OpenSSL implementation from 1998 up until its patch in 2015, when the authors of DROWN contacted the OpenSSL developers.&lt;/p&gt;

&lt;h2 id=&#34;prevention-of-drown&#34;&gt;Prevention of DROWN&lt;/h2&gt;

&lt;p&gt;The attack is successful mainly because of the reliance on obsolete cryptographic practices. Export-grade ciphers only support 40-bit keys which are vulnerable to brute-force attack and hence it is crucial to disable export-grade ciphers and use safer ciphers (like &lt;a href=&#34;https://tools.ietf.org/html/rfc5288&#34;&gt;AES_GCM&lt;/a&gt;) with longer key lengths (256-bits). PKCS#1 v1.5 padding leaks significant byte patterns and hence a better padding technique should be used. SSLv2 protocol includes the above obsolete cryptos and hence it should be scrapped and replaced with TLS 1.3. Lastly, the RSA public keys should not be shared among multiple servers or connections in order to deter the attack.&lt;/p&gt;

&lt;h1 id=&#34;state-level-threats-to-diffie-hellman&#34;&gt;State-Level Threats to Diffie-Hellman&lt;/h1&gt;

&lt;h2 id=&#34;current-situation&#34;&gt;Current Situation&lt;/h2&gt;

&lt;p&gt;In recent years, the general bar for internet security has raised substantially. HTTPS is now the norm for most heavily trafficked websites and is spreading through services such as Let’s Encrypt, that allow for domain owners to easily get SSL certificates for a website at no cost. In general, this trend looks positive: for key exchange protocols, stronger 768 and 1024-bit groups are now the norm rather than the exception. Individual users and institutions have also begun to better understand the need for security and IPSec Virtual Private Networks (VPNs) and SSH connects are being more broadly practiced.&lt;/p&gt;

&lt;h2 id=&#34;academic-power&#34;&gt;Academic Power&lt;/h2&gt;

&lt;p&gt;While standards have advanced and security has increased in general, cryptanalysis techniques and computational power have also increased. Although ideas such as Moore’s Law, that computing power at a certain price level effectively doubles every 18 months, the practical implications are not as often taken into account. These days, DH-512 is easily within the reach of “academic power,” that is to say, within the reach of institutions with access to midsize computing facilities or individuals who can afford a few hundred thousand dollars of computing.&lt;/p&gt;

&lt;p&gt;With recent hardware, to “crack” DH-512 takes 2.5 core-years in the sieving phase, 7.7 core-years in the linear algebra phase, but only 10 core-minutes in the descent phase. So, given a 2000-3000 core cluster, all of the phases combined except the descent phase takes about 140 hours.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/downgrade-attacks/dh512.png&#34; alt=&#34;DH-512 Computational Cost&#34; style=&#34;width:500px;&#34;/&gt;
&lt;br&gt;
&lt;sup&gt;&lt;a href=&#34;https://weakdh.org/weakdh-ccs-slides.pdf&#34;&gt;https://weakdh.org/weakdh-ccs-slides.pdf&lt;/a&gt;&amp;gt;&lt;/sup&gt;
&lt;br&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;However, the descent phase only takes about 70 seconds. What does this mean? That after 1 week of pre-computation, an individual calculation can be completed in about 70s. If this is combined with something called a “downgrade attack,” which will be described below, connections to about &lt;strong&gt;8%&lt;/strong&gt; of top 1 million sites that use HTTPS can be broken in real time.&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3 id=&#34;sidebar-what-s-a-core-year&#34;&gt;Sidebar: What’s a Core Year?&lt;/h3&gt;

&lt;p&gt;A “core-year” is a measure of the amount of work that an average computer core can complete in a year. To give a point of reference in terms of concrete cost, a single-core Amazon EC2 instance costs about $0.02 / hours. To run that core for a year would cost about $0.02 * (24 *365) = $175. A core-day and a core-minute are defined similarly.&lt;/p&gt;

&lt;p&gt;Although it may seem like this isn’t as serious of a problem, since current practice is usually to use DH-768 or DH-1024 &amp;ndash;for example, 91.0% of IKEv2 servers support a 1024-bit connection&amp;ndash; in actuality even those are vulnerable to attack. In 2009, a new record was achieved for integer factorization with a 768 bit integer factorization completed with academic resources over the span of 2 years. This would imply that breaking DH-768 takes about 36,500 core-years in pre-computation and 2 core-days in decent. As much as this sounds, it is only a few million dollars worth, which is well within reach of both moderately-funded academics and moderately-motivated adversaries (and peanuts for an organization like the NSA).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;structural-costs&#34;&gt;Structural Costs&lt;/h2&gt;

&lt;p&gt;Ok, so a DH-768 connection can probably be broken by a non-state-level actor, but what about a DH-1024 connection? Surely that is ok? Let’s take a look at the costliness of DH-1024 in comparison to 768-bit DH. The algorithmic time complexity increases by a factor of about 1220, the space complexity by a factor of 95, leaving us with this:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/downgrade-attacks/dhall.png&#34; alt=&#34;Computational cost of different DH group sizes&#34; style=&#34;width:500px;&#34;/&gt;
&lt;br&gt;
&lt;sup&gt;&lt;a href=&#34;https://weakdh.org/weakdh-ccs-slides.pdf&#34;&gt;https://weakdh.org/weakdh-ccs-slides.pdf&lt;/a&gt;&lt;/sup&gt;
&lt;br&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Although the costs seem astronomically high, they are actually within the reach of a state-level actor. If we assume that some special purpose ASICs are developed to help speed up the sieving pre-computation such that it can be completed in one year (this would cost around $8 million), and we get access to, say, a Titan supercomputer for one year (at a cost of $122 million) to complete the linear algebra phase in one year, we find that we can complete all of our pre-computation for the small cost of $130 million dollars.  Compare this cost to the budget of a state-level actor such as the NSA: their 2012 budget was $10.5 billion, making this computation just 1% of that budget.&lt;/p&gt;

&lt;h2 id=&#34;what-s-so-good-about-breaking-one-group&#34;&gt;What’s so Good About Breaking One Group?&lt;/h2&gt;

&lt;p&gt;But, you might object, what is the value in doing this pre-computation and breaking one group? Doesn’t this just mean that the NSA can only break a couple connections per year? Unfortunately, no. As Edward Snowden said, “If performing number field sieve pre-computations for at least a small number of 1024-bit Diffie-Hellman groups is possible, breaking any key exchanges made with those groups in close to real time is no difficulty.” This is because once the pre-computations are completed for a single group, that work can then be used to crack numerous connections.&lt;/p&gt;

&lt;h2 id=&#34;ike-ipsec-vpns&#34;&gt;IKE (IPsec VPNs)&lt;/h2&gt;

&lt;p&gt;Let’s now take a step back and look at IKE, the Internet Key Exchange, which perhaps is the most vulnerable to these kinds of attacks. IKE is a protocol used, in the IPsec protocol, to create a “Security Association (SA),” which is just a set of shared security attributes between two network parties such as cryptographic algorithm being used, the algorithm mode, credentials, etc. In order to establish the SA, two parties go through a process like this:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/downgrade-attacks/ike.png&#34; alt=&#34;IKE Protocol Description&#34; style=&#34;width:600px;&#34;/&gt;
&lt;br&gt;
&lt;sup&gt;&lt;a href=&#34;https://weakdh.org/weakdh-ccs-slides.pdf&#34;&gt;https://weakdh.org/weakdh-ccs-slides.pdf&lt;/a&gt;&lt;/sup&gt;
&lt;br&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;While the exact details of how the protocol works are not important, it is important to note that to perform IKE passive decryption, an adversary would have to have access to a known pre-shared key, both sides of the IKE handshake, and both the handshake traffic and ESP traffic.&lt;/p&gt;

&lt;p&gt;Also important to note is that the vast majority of IKE systems use one particular 1024-bit DH group, the Oakley Group 2, for the protocol. We find that 86.1% of IKEv1 servers and 91.0% of IKEv2 servers support Oakley Group 2, and 66.1% of IKEv1 servers and 63.9% of IKEv2 servers chose Oakley Group 2 for the protocol. This means that a state-level actor with access to the pre-shared key, both sides of the IKE handshake, and both the handshake traffic and ESP traffic would be able to &lt;strong&gt;passively decrypt 66%&lt;/strong&gt; of VPN server traffic&amp;hellip;in near real-time.&lt;/p&gt;

&lt;h2 id=&#34;show-me-the-adversary&#34;&gt;Show me the Adversary&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Is this all hypothetical? Does any such adversary actually exist?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A 2012 Wired article revealed information that the NSA, several years before 2012, made an “enormous breakthrough” in its ability to cryptanalyze current public encryption. While the exact details are not known, it may be reasonable to assume that the NSA completed the pre-computation for a 1024-bit DH group, such as the Oakley Group 2, allowing them passive decrypted access to a swath of internet traffic.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/downgrade-attacks/impact.png&#34; alt=&#34;Impact of a break&#34;/&gt;
&lt;sup&gt;&lt;a href=&#34;https://weakdh.org/weakdh-ccs-slides.pdf&#34;&gt;https://weakdh.org/weakdh-ccs-slides.pdf&lt;/a&gt;&lt;/sup&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;The impact of such a break to IKE has already been noted. Other protocols would also be vulnerable to the break. SSH, for example, supports Oakley Group 2, Oakley Group 14, or a server-defined group that is negotiated through a DH-GEX handshake. According to recent data, 21.8% of servers prefer Oakley Group 2, and 37.4% prefer the server-defined group. However, of that 37.4%, almost all of them just provided Oakley Group 2 rather than a real custom group. Thus, a state-level attacker that performed the break could passively eavesdrop on connections to 25.7% of all publicly accessible SSH servers.&lt;/p&gt;

&lt;p&gt;Unfortunately, HTTPS connections are similarly affected. Of the top 1 million site that support DHE, 84% use a 1024-bit or smaller group, and 94% of those use one of five common groups. Thus, 17.9% of connections to the top 1 million sites could be passively eavesdropped with the pre-computation for a single 1024-bit prime.&lt;/p&gt;

&lt;h2 id=&#34;mitigations&#34;&gt;Mitigations&lt;/h2&gt;

&lt;p&gt;Is there any hope that a connection can really be secure given this information? Luckily, some mitigations can be put into place. First, servers can move to using elliptic curve cryptography (ECC). A transition to a elliptic curve Diffe-Hellman key exchange (ECDH) with appropriate parameters would thwart all known feasible cryptanalytic attacks as ECC discrete log algorithms don&amp;rsquo;t gain too much advantage from precomputation. When ECC is not an option, it is recommended that primes at least 2048 bits in length be used. It would be ideal if browser vendors and clients raise the minimum accepted size for DH groups to at least 1024 bits. If large primes are not supported, then always use a fresh 1024-bit group to mitigate the efficacy of precomputation-based attacks. It is parameter reuse that allows state-level attackers to easily perform wide-scale passive decryption.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Padding Oracle Attacks</title>
      <link>https://tlseminar.github.io/padding-oracle/</link>
      <pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://tlseminar.github.io/padding-oracle/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://tlseminar.github.io/https://tlseminar.github.io/first-few-milliseconds/&#34;&gt;Last week&lt;/a&gt;, we
examined how the Transport Layer Security (TLS) protocol provides a
private channel between two devices by following the handshake and
record layers protocols. The handshake layer establishes a symmetric
key that both the client and the server could use in the record layer
to encrypt and decrypt messages.&lt;/p&gt;

&lt;p&gt;This week, we&amp;rsquo;ll discuss a real-world TLS attack, the Padding Oracle
Attack, that takes advantage of our need for each message to be a
particular set length. If the original message is not long enough,
then we have to add padding for the &lt;a href=&#34;https://tlseminar.github.io/docs/analysisssl3.pdf&#34;&gt;CBC Mode
Encryption&lt;/a&gt; to
work. Because the padding is present, an attacker can chip away
information on the
&lt;a href=&#34;https://tlseminar.github.io/docs/beast.pdf&#34;&gt;ciphertext&lt;/a&gt;, one byte at
a time, through analyzing the receiver’s error messages for the
sender, &lt;a href=&#34;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&#34;&gt;response time&lt;/a&gt;,
and general behavior.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start out by learning about how &lt;a href=&#34;https://tlseminar.github.io/docs/analysisssl3.pdf&#34;&gt;CBC Mode
Encryption&lt;/a&gt; works.&lt;/p&gt;

&lt;h1 id=&#34;padding-and-cbc-mode&#34;&gt;Padding and CBC Mode&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tlseminar.github.io/docs/analysisssl3.pdf&#34;&gt;&lt;em&gt;Analysis of the SSL 3.0 Protocol&lt;/em&gt;&lt;/a&gt; by David Wagner and Bruce Schneider (1997)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When AES-128 encryption is performed in cipher block chaining mode
(CBC mode), the plaintext message is first split up into 16-byte
(128-bit) blocks. It is often the case, however, that the length of
the message is not perfectly divisible by 16. To account for varying
message sizes, extra bytes, called padding, are concatenated after the
end of the message to fill up the remaining quota for the final block.&lt;/p&gt;

&lt;p&gt;These bytes are not chosen at random, however, and different cipher
modes prescribe different padding methods. In order to clearly mark
for the recipient where the message ends and the padding begins, the
padding follows a strict formatting pattern. With PKCS #5 padding as
used in TLS, if there are &lt;em&gt;n&lt;/em&gt; bytes of padding, then each padding byte
contains the value &lt;em&gt;n&lt;/em&gt;. For instance, if the last block contains 15
message bytes, the 1-byte padding contains &lt;code&gt;0x01&lt;/code&gt;; if the last block
contains 14 message bytes, the 2-byte padding contains &lt;code&gt;0x0202&lt;/code&gt;;
3-byte padding contains &lt;code&gt;0x030303&lt;/code&gt;; and so on.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://tlseminar.github.io/images/paddingoracle/padding.png&#34; alt=&#34;Padding&#34;&gt;&lt;Br&gt;
&lt;span class=&#34;caption&#34;&gt;&lt;em&gt;Source: &lt;/em&gt;&lt;a href=&#34;https://blog.gdssecurity.com/labs/2010/9/14/automated-padding-oracle-attacks-with-padbuster.html&#34;&gt;Gotham Digital Science&lt;/a&gt;&lt;/span&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;In CBC mode, the bytes of each plaintext block n are first XOR’ed with
the encrypted bytes of the block before it, and their result is then
encrypted. Block 1 is the obvious exception, which is XOR’ed with a
fixed, random, or secret initialization vector (IV). Thus, for any
block &lt;em&gt;n&lt;/em&gt; &amp;gt; 1, where E&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; is the encryption function,
&lt;em&gt;c&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt; is the encrypted block &lt;em&gt;n&lt;/em&gt;, &lt;em&gt;p&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt; is the plaintext
block &lt;em&gt;n&lt;/em&gt;, and &lt;em&gt;c&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;-1&lt;/sub&gt; is the encrypted block &lt;em&gt;n&lt;/em&gt;-1:
&lt;center&gt;
&lt;em&gt;c&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt; = E&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; (&lt;em&gt;p&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;⊕ &lt;em&gt;c&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;-1&lt;/sub&gt;)
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/paddingoracle/cbc.png&#34; alt=&#34;cbc-mode&#34; /&gt;&lt;br&gt;
&lt;span class=&#34;caption&#34;&gt;&lt;em&gt;Source: &lt;/em&gt;&lt;a href=&#34;https://www.cs.rit.edu/~ark/fall2012/482/module05/CbcEncrypt.png&#34;&gt;Alan Kaminsky&lt;/a&gt;&lt;/span&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;However, the predictability of the padding format can turn out to be
an extremely exploitable weakness for an active attacker. Under
SSL/TLS protocol, when servers receive an encrypted message, their
first step upon decryption is to check the validity of the padding;
that is, determine if the numbers at the end of the last block
represent the number of padding bytes. As soon as this step is
completed, the server will return to the sender either an error code
or an acknowledgment that the padding is valid. In this way, the
server acts as an oracle to an active attacker, providing them with
confirmations/rejections to inform their guesses.&lt;/p&gt;

&lt;h1 id=&#34;padding-oracle-attack&#34;&gt;Padding Oracle Attack&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.iacr.org/cryptodb/archive/2002/EUROCRYPT/2850/2850.pdf&#34;&gt;&lt;em&gt;Security Flaws Induced by CBC Padding Applications to SSL, ISPEC, WTLS&amp;hellip;&lt;/em&gt;&lt;/a&gt; by Serge Vaudenay&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To begin, the attacker creates a Last Word Oracle. This first assumes
a 1-byte padding, so the format that the oracle would return as valid
is &lt;code&gt;0x01&lt;/code&gt; XOR’ed with some particular value in the corresponding last
position in the &lt;em&gt;n&lt;/em&gt;-1th block. Since the last byte, or word, can have
256 distinct values, the attacker can simply manipulate the &lt;em&gt;n&lt;/em&gt;-1th
block, easily testing all values, until either the possibilities are
exhausted or the padding is returned as valid. If the possibilities
are exhausted, then the attacker instead tries &lt;code&gt;0x02&lt;/code&gt;, then &lt;code&gt;0x03&lt;/code&gt;,
and on until the padding returned is valid.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/paddingoracle/last-word.png&#34; alt=&#34;LastWordOracle&#34; /&gt;&lt;br&gt;
&lt;span class=&#34;caption&#34;&gt;&lt;em&gt;Source: &lt;/em&gt;&lt;a href=&#34;https://www.rsaconference.com/writable/presentations/file_upload/asec-403.pdf&#34;&gt;Brian Holyfield, Gotham Digital Science&lt;/a&gt;&lt;/span&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Once the attacker has learned the padding, a Block Decryption Oracle
is constructed, using the values of the encrypted &lt;em&gt;n&lt;/em&gt;-1th block to,
byte by byte, guess the preceding byte, using the oracle’s pass/fail
responses to confirm correct guesses. This method is then extended to
decrypt all other blocks, as it is called on pairs containing a random
block and a ciphertext block. (Again, the logical exception is the
first block, assuming an independent initialization vector.) This is a
terrifyingly efficient attack; to implement it, the attacker only
needs (&lt;em&gt;b&lt;/em&gt; * &lt;em&gt;W&lt;/em&gt; * &lt;em&gt;N&lt;/em&gt;)/2 trials, where &lt;em&gt;b&lt;/em&gt; is the number of bytes per block,
&lt;em&gt;W&lt;/em&gt; is the number of possible bytes, and &lt;em&gt;N&lt;/em&gt; is the number of blocks.&lt;/p&gt;

&lt;p&gt;With the CBC Padding now added to the original ciphered message,
attackers can alter this new message with blockwise operations in
order to draw information out of the originally unreadable
ciphertext. This information could potentially end up being
authentication tokens, such as cookies, granting attackers personally
identifiable information or the potential to hijack previous sessions.&lt;/p&gt;

&lt;h1 id=&#34;beast-plaintext-attacks-against-ssl&#34;&gt;BEAST: Plaintext Attacks Against SSL&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tlseminar.github.io/docs/beast.pdf&#34;&gt;&lt;em&gt;Here Come The \(\oplus\) Ninjas&lt;/em&gt;&lt;/a&gt; by Thai Duong and Juliano Rizzo (2011)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In CBC block encryption, each plaintext block is XORed with the
ciphertext of the previous block before being encrypted. An attempted
guess at a plaintext block can be evaluated by encrypting the
ciphertext prior to the block in question XORed with the ciphertext
prior to the current block XORed with the guess; if the new ciphertext
matches that of the block in question, then the guess is
correct:
&lt;center&gt;
C&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt; = E&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;(P&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt; ⊕ C&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;-1&lt;/sub&gt;), so, C&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;==C&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt; iff P&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; == P&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt; ⊕ C&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;-1&lt;/sub&gt; ⊕ C&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;-1&lt;/sub&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Guess G can be evaluated as equal to or unequal to plaintext
P&lt;sub&gt;j&lt;/sub&gt; by setting P&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;=G ⊕ C&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;-1&lt;/sub&gt; ⊕
C&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;-1&lt;/sub&gt; and checking whether or not C&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt; ==
C&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;. An attacker would need to be able to view the
encrypted messages and query the underlying CBC encryption system to
be able to mount an attack based on this exploit.&lt;/p&gt;

&lt;p&gt;Cryptographic systems are limited in their size and ability to store
large plaintext messages, for this reason, most cryptographic systems
encrypt messages block by block as they are sent. In the case where an
attacker can append padding to a message before it is encrypted, an
attacker can mount a blockwise chosen-boundary attack, in which the
first byte of an unknown message is isolated by padding, enabling the
attacker to guess at single bytes of a message rather than block-sized
chunks.&lt;/p&gt;

&lt;p&gt;The natural extension of this is to repeat the process such that once
a byte of message has been guessed by the attacker, the padding is
changed such that a single unknown byte of message is encrypted with
padding and bytes known to the attacker, allowing them to continue
guessing at single bytes of information.&lt;/p&gt;

&lt;p&gt;Duong and Rizzo go on to describe the process whereby this attack
could be mounted on HTTPS to obtain a user’s HTTP cookie. The attack
only requires that an attacker can view encrypted messages, can cause
the client to make arbitrary encrypted requests, and that arbitrary
plaintext can be added to out-going requests. In the described attack,
the user is made to request a package with a padded end such that the
first byte of unknown information in the request is isolated in an
encryption with only public information. The attacker then makes
guesses at that byte of information, appending plaintext to the
request and watching the encrypted channel for a message block that
matches the block containing the unknown byte of information. At that
point, the guess that resulted in that message block is identified as
the correct guess. The process is then repeated with a smaller padding
until the user’s request header (including their HTTPS cookies) is
revealed to the attacker.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/paddingoracle/beast.png&#34; alt=&#34;beast&#34; /&gt;&lt;br&gt;
&lt;span class=&#34;caption&#34;&gt;&lt;em&gt;Figure: &lt;/em&gt;Attacker (Mallory) is able to sniff encrypted traffic, force Alice to send cookie-bearing HTTP requests, and insert forged plaintexts in the conversation.&lt;/span&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;There are a few issues mentioned associated with this attack, but by
using one of a variety of plugins, an attacker could make the user
open bi-directional communication with the server. On this
communication channel, the privileges required by the attacker to
mount the attack would be easier to gain.&lt;/p&gt;

&lt;h1 id=&#34;lucky-13-plaintext-recovery-from-injected-ciphertext&#34;&gt;Lucky 13: Plaintext Recovery from Injected Ciphertext&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&#34;&gt;&lt;em&gt;Lucky Thirteen: Breaking the TLS and DTLS Record Protocols&lt;/em&gt;&lt;/a&gt; by Nadhem J. Alfardan and Kenneth G. Paterson (2013)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Similar in the vein of the BEAST attack using bitwise XOR operations
to glean useful plaintext information, Lucky Thirteen offers yet
another alternative means to get partial or even full plaintext
recovery with just a simple man-in-the-middle injecting ciphertext
into the original ciphertext. Based on analyzing how TLS and DTLS
decrypt a given ciphertext, these attacks also rely on CBC-mode
weaknesses.&lt;/p&gt;

&lt;p&gt;The Lucky 13 attack relies on a timing channel introduced by the
difference in processing time between TLS records with correct and
incorrect padding, requiring only a standard in-the-middle attacker
for execution and providing recovered plaintext in the most severe
case.  This would indicate a major security flaw, even in comparison
to the aforementioned BEAST attack. BEAST required capabilities beyond
simple MITM on the part of the attacker.  As a result, the authors of
the paper disclosed their results to all major vendors to allow for
patching before publishing.&lt;/p&gt;

&lt;p&gt;The name “Lucky 13” is a reference to a specific breakpoint in the
size of the padding on a given message.  Both TLS and DTLS use the
HMAC algorithm to compute MAC tags for messages.  HMAC operates using
a compression function on messages with lengths equal to multiples of
64 bytes, so TLS and DTLS pad out messages with remaining space.&lt;/p&gt;

&lt;p&gt;After subtracting 8 bytes for the length field and 1 byte of mandatory
padding, we are left with a maximum message length of 55 bytes that
can be encoded within one block.  This means that messages less than
55 bytes can be processed with only four compression function
evaluations, and that in general the number of compressions is equal
to&lt;/p&gt;

&lt;p&gt;$$\left\lceil\frac{L-55}{64}\right\rceil+4$$&lt;/p&gt;

&lt;p&gt;for messages of &lt;em&gt;L&lt;/em&gt; bytes.  The compression function is relatively expensive, so the difference between 4 and 5 iterations is distinguishable in good conditions.  It is also possible to submit multiple requests as described below to amplify the differences if necessary.&lt;/p&gt;

&lt;p&gt;The authors detail first a distinguishing attack, and then a variation allowing for full plaintext recovery.  All attacks rely on the timing channel.  Specifically, the authors describe in detail how it is possible to place a target ciphertext block at the end of an encrypted record, causing the decryption function to interpret the plaintext block corresponding to the ciphertext block as padding.  Thus the amount of time required to process that block depends on plaintext bytes, leaking information.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://tlseminar.github.io/images/paddingoracle/timing.png&#34; alt=&#34;lucky-thirteen&#34; /&gt;&lt;Br&gt;
&lt;span class=&#34;caption&#34;&gt;&lt;em&gt;Figure:&lt;/em&gt; Graph showing the differences in timing due to the number of compressions necessary for varying lengths of bytes.&lt;br&gt;&lt;em&gt;Source: &lt;/em&gt;&lt;a href=&#34;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&#34;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt;
&lt;/span&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Through these readings and their respective explanations, we see that
cryptographic protocols are often broken and need to be patched. There
is always some threat model out there looking to exploit the first
sign of weakness to decrypt and listen in on what should be a secure,
encrypted channel. Through this last week, we focused on looking at
padding oracle attacks which take advantage of the padding on the
respective blocks in a CBC chain as they are passed from operation to
operation. With the last word oracle and the BEAST attack, we saw how
important this padding was to the security of the whole
operation. With our look at Lucky 13, we were able to see that people
were able to exploit the fact that one extra compression had to be
done in certain situations to glean information about the message. As
such, we see just from the padding, we have so many attacks.&lt;/p&gt;

&lt;p&gt;There are so many aspects to SSL/TLS protocols that so many more
exploits exist. So, what are ways that we can prevent these attacks?
With the padding attacks, we saw that they tried standardizing error
messages (but, why not just encrypt the message and send it
back?). Should our strategy just be to move as quickly to the newest
version of the security protocols? Should we add the MAC to the
messages after encryption?&lt;/p&gt;

&lt;p&gt;TLS 1.3 (the most recent release) has been drafted (and in the process
of release) and has resolved many of these issues that have exploited
weaknesses present in older versions of the protocol. However, its
adoption rate has been very low and so it is important to bring this
up as more and more operations should be moved over to TLS 1.3, as
this seems to be the most secure system we have available right now
and thus should be adopted.&lt;/p&gt;

&lt;h1 id=&#34;sources&#34;&gt;Sources&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://tlseminar.github.io/docs/analysisssl3.pdf&#34;&gt;https://tlseminar.github.io/docs/analysisssl3.pdf&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.iacr.org/cryptodb/archive/2002/EUROCRYPT/2850/2850.pdf&#34;&gt;http://www.iacr.org/cryptodb/archive/2002/EUROCRYPT/2850/2850.pdf&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://tlseminar.github.io/docs/beast.pdf&#34;&gt;https://tlseminar.github.io/docs/beast.pdf&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&#34;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The First Few Milliseconds of an TLS 1.2 Connection</title>
      <link>https://tlseminar.github.io/first-few-milliseconds/</link>
      <pubDate>Thu, 26 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://tlseminar.github.io/first-few-milliseconds/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;In 2009, Jeff Moser published &lt;a href=&#34;http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html&#34;&gt;an excellent article&lt;/a&gt; on the first few milliseconds of an HTTP request. It described in detail how TLS 1.0 connections are established, including a great description of RSA. We&amp;rsquo;ve attempted to build and adapt upon that article here by describing how the process works for a TLS 1.2 connection. As of January 2nd 2017, TLS 1.2 has roughly &lt;a href=&#34;https://www.trustworthyinternet.org/ssl-pulse/&#34;&gt;83.2% adoption&lt;/a&gt; among top websites, so now is a great time to dive in.&lt;/p&gt;

&lt;p&gt;The process of conecting via TLS 1.2 begins when the user attempts to navigate to a website. For this description, we are attempting to navigate to &lt;a href=&#34;https://example.com/&#34;&gt;https://example.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tls-layers&#34;&gt;TLS Layers&lt;/h2&gt;

&lt;p&gt;The TLS protocol is composed of several layers, which come together to form each request. Here are descriptions of the common layers&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/gnutls-layers.png&#34; alt=&#34;tls layers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Transport Layer&lt;/strong&gt; - The protocol over which TLS data is distributed. For HTTPS, this will be TCP. Needs only to be reliable (packet loss must be handled). Not a direct part of TLS.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Record Layer&lt;/strong&gt; - The record layer handles sending/receiving TLS messages, including data fragmentation for packets, (optional and bad) compression, and encryption.&lt;/p&gt;

&lt;p&gt;The next three are common protocols that operate within the body of the Record Layer. TLS extensions can specify additional protocols.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Handshake Protocol&lt;/strong&gt; - Responsible for choosing a cipher suite, connection parameters, and coordinating a shared secret.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alert Procotol&lt;/strong&gt; - Used to communicate warnings and errors. The most common alerts are for an invalid server certificate or to signal the end of a TLS connection when the client exits.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Application Protocol&lt;/strong&gt; - Raw higher-level application data transmitted by TLS. For us, this is HTTP.&lt;/p&gt;

&lt;p&gt;Now, onto the first few milliseconds of a TLSv1.2 request!&lt;/p&gt;

&lt;h2 id=&#34;part-0-the-record-layer&#34;&gt;Part 0: The Record Layer&lt;/h2&gt;

&lt;p&gt;Since the following packets will be wrapped in a Record Layer struct, it&amp;rsquo;s worth describing that here.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/record-layer.png&#34; alt=&#34;record layer struct&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The record packet specifies the Content Type of the request, the TLS version, data length, and then the content data (in this image, a handshake clienthello).&lt;/p&gt;

&lt;p&gt;Note that the version specified in the record layer is often different from that specified in the handshake. This is for compatibility with some old TLS/SSL servers. You will often see the version here specified as TLS 1.0 (0x0103, or SSL 3.0)&lt;/p&gt;

&lt;h2 id=&#34;part-1-client-hello&#34;&gt;Part 1: Client Hello&lt;/h2&gt;

&lt;p&gt;Our web browser (Microsoft Edge 38.14393.0.0 on Windows 10) will begin the TLS 1.2 handshake with a ClientHello record.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/client-hello.png&#34; alt=&#34;clienthello record&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see several important fields here worth mentioning. First, the &lt;strong&gt;time&lt;/strong&gt; (GMT seconds since midnight Jan 1, 1970) and &lt;strong&gt;random&lt;/strong&gt; bytes are included. This will be used later in the protocol to generate our symmetric encryption key.&lt;/p&gt;

&lt;p&gt;The client can send an optional &lt;strong&gt;session ID&lt;/strong&gt; (not sent in this case) to quickly resume a previous TLS connection and skip portions of the TLS handshake.&lt;/p&gt;

&lt;p&gt;Arguably the most important part of the ClientHello message is the list of &lt;strong&gt;cipher suites&lt;/strong&gt;, which dictate the key exchange algorithm, bulk encryption algorithm (with key length), MAC, and a psuedo-random function. The list should be ordered by client preference. The collection of these choices is a &amp;ldquo;cipher suite&amp;rdquo;, and the server is responsible for choosing a secure one it supports, or return an error if it doesn&amp;rsquo;t support any.&lt;/p&gt;

&lt;p&gt;The final field specified in the specification is for &lt;strong&gt;compression methods&lt;/strong&gt;. However, secure clients will advertise that they do not support compression (by passing &amp;ldquo;null&amp;rdquo; as the only algorithm) to avoid the &lt;a href=&#34;https://en.wikipedia.org/wiki/CRIME_(security_exploit)&#34;&gt;CRIME attack&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, the ClientHello can have a number of different extensions. A common one is &lt;strong&gt;server_name&lt;/strong&gt;, which specifies the hostname the connection is meant for, so webservers hosting multiple sites can present the correct certificate.&lt;/p&gt;

&lt;h2 id=&#34;server-hello&#34;&gt;Server Hello&lt;/h2&gt;

&lt;p&gt;Once the server has processed our ClientHello, it will respond with a TLSv1.2 ServerHello message&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/server-hello.png&#34; alt=&#34;serverhello message&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This message returns several important fields, beginning with the TLS &lt;strong&gt;version&lt;/strong&gt; to be used, usually the highest version supported by both client and server. It also includes the server &lt;strong&gt;time&lt;/strong&gt; (not sure why example.com is so off!) and 28 &lt;strong&gt;random bytes&lt;/strong&gt; for use later.&lt;/p&gt;

&lt;p&gt;The server also makes a &lt;strong&gt;cipher suite selection&lt;/strong&gt; from the list chosen by the client. This should be the strongest suite supported by both. In our case, the server has chosen TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, indicating the following:
* Key Exchange: Elliptic curve diffie-hellman, signed with RSA
* Encryption: AES in GCM mode with 128 bit keys
* MAC: SHA256&lt;/p&gt;

&lt;h2 id=&#34;certificate&#34;&gt;Certificate&lt;/h2&gt;

&lt;p&gt;After the ServerHello, the server will send a certificate chain to the client if applicable.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/server-certificate.png&#34; alt=&#34;server certificate message&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Each certificate comes with information about domains it supports, who it was issued by, and the time period (start and end) of its validity.&lt;/p&gt;

&lt;p&gt;The certificate chain is a list of certificates beginning with the TLS certificate for the current domain, and ending in a root certificate that is built-in to the web browser. Each certificate is signed by the certificate above it in the chain, and it is this chain that the client validates to verify the server.&lt;/p&gt;

&lt;p&gt;In our case, example.com has a certificate issued by &amp;ldquo;DigiCert SHA2 High Assurance&amp;rdquo;, which in turn is issued by the root certificate &amp;ldquo;DigiCert High Assurance EV Root CA.&amp;rdquo; On Windows, you can view the list of root certificates on your system with &lt;code&gt;certmgr.msc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/certmgr.png&#34; alt=&#34;certmgr&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see the DigiCert High Assurance EV Root CA in our store, along with several other DigiCert certificates. OSX allows you to see root certificates using the &amp;ldquo;Keychain Access&amp;rdquo; program, where they are listed under &amp;ldquo;System Roots&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/keychain-access.png&#34; alt=&#34;osx keychain access&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In general, browsers will defer to the operating system root certificates as the central store for their validation. One notable exception is Firefox, which uses its own certificate store and ignores system root certificates by default.&lt;/p&gt;

&lt;p&gt;Root CA certificates are implicitly trusted by every system they&amp;rsquo;re included on. An attacker who manages to control their private key could impersonate any website without raising any red flags, so it&amp;rsquo;s important that the certificate authorities keep them safe (&lt;a href=&#34;https://www.mail-archive.com/dev-security-policy@lists.mozilla.org/msg05455.html&#34;&gt;but that doesn&amp;rsquo;t always happen&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;optional-certificate-status-ocsp&#34;&gt;Optional: Certificate Status (OCSP)&lt;/h2&gt;

&lt;p&gt;One increasingly common extension is the Online Certificate Status Protocol (OCSP), used for certificate revocations. OCSP servers can be consulted by clients to check if the server certificate has been revoked, which helps solve a critical problem with TLS certificates. Servers response to certificate requests by issuing a signed response from the CA with a status code indicating whether or not the certificate is valid.&lt;/p&gt;

&lt;p&gt;Prior to wide deployment of OCSP, TLS vendors shipped certificate revocation lists (CRLs) that contained serial numbers of revoked certificates.&lt;/p&gt;

&lt;p&gt;To reduce load, servers often cache the OCSP response and send it as a Certificate Status TLS message (OCSP stapling). This helps reduce load on the OCSP system and protects attackers from analyzing OCSP requests to determine client browsing habits. The server will send this cached message in response to a &lt;strong&gt;status_request&lt;/strong&gt; extension in the ClientHello message.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/ocsp-stapling.png&#34; alt=&#34;ocsp stapling&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Each OCSP ticket is signed by a trusted OCSP server. The response itself consists of a &lt;strong&gt;responseStatus&lt;/strong&gt; and optional &lt;strong&gt;responseBytes&lt;/strong&gt; with additional information.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/ocsp-response.png&#34; alt=&#34;ocsp response info&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In our case, the OCSP ticket is valid and cached for 7 days (1/20 to 1/27). The server itself is responsible for refreshing its OCSP ticket at that time.&lt;/p&gt;

&lt;h2 id=&#34;serverkeyexchange&#34;&gt;ServerKeyExchange&lt;/h2&gt;

&lt;p&gt;For DHE key-exchanges (DHE_DSS, DHE_RSA, and DH_anon), the server will use a ServerKeyExchange message to specify the parameters for the algorithm.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/dhe-params.png&#34; alt=&#34;dhe parameters&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The server has specified a &lt;strong&gt;named_curve&lt;/strong&gt; curve type using the &lt;strong&gt;secp256r1&lt;/strong&gt; elliptic curve (also known as &lt;strong&gt;P-256&lt;/strong&gt; or &lt;strong&gt;prime256v1&lt;/strong&gt;). This is a public &lt;a href=&#34;http://www.secg.org/sec2-v2.pdf&#34;&gt;NIST standard curve&lt;/a&gt;. With knowledge of the curve to be used, both the server and client will know the crucial $p$ and $G$ values for ECDHE. For secp256r1, these are defined by NIST as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p = FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF

G = 03 6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The server will choose a random private key and compute $a*G$ as its &lt;strong&gt;public key&lt;/strong&gt;. In addition to this it also signs the data with its private key - signing &lt;code&gt;SHA256(client_random + server_random + server_params)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;server-hello-done&#34;&gt;Server Hello Done&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/server-hello-done.png&#34; alt=&#34;serverhellodone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This short message from the server tells the client it&amp;rsquo;s done sending information. Nothing more.&lt;/p&gt;

&lt;h2 id=&#34;clientkeyexchange&#34;&gt;ClientKeyExchange&lt;/h2&gt;

&lt;p&gt;Now, the client must  send its own ephemeral public key (for DH).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/client-dhe-key.png&#34; alt=&#34;client dhe key&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is calculated by generating a random private key $b$ and from there calculating $b*G$ as its public key.&lt;/p&gt;

&lt;h2 id=&#34;completing-the-key-exchange&#34;&gt;Completing the Key Exchange&lt;/h2&gt;

&lt;p&gt;Now that the client has $a*G$ and the server $b*G$, both can calculate the final secret value $a*b*G$ with their own private keys. This is known as the &lt;strong&gt;pre-master secret&lt;/strong&gt;. The key detail here is that calculating $a*b*G$ from $a*G$ and $b*G$ alone is computationally difficult.&lt;/p&gt;

&lt;p&gt;We just have one final step to convert our pre-master secret into the final &lt;strong&gt;master secret&lt;/strong&gt;. We will use the random bytes generated by the client and server earlier along with our chosen psuedo-random function. For us, that was SHA-256.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master_secret = PRF(pre_master_secret, &amp;quot;master secret&amp;quot;, client_random + server_random)[0..47]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The TLS 1.2 spec defines the PRF as &lt;code&gt;PRF(secret, label, seed)&lt;/code&gt; which expands to &lt;code&gt;P_SHA256(secret, label + seed)&lt;/code&gt;. The label is the literal ASCII string &amp;ldquo;master secret&amp;rdquo; without any null terminator. This expands to the following definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;P_sha256(secret, seed) = HMAC_sha256(secret, A(1) + seed) +
                         HMAC_sha256(secret, A(2) + seed) +
                         HMAC_sha256(secret, A(3) + seed) +
                         ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;A(x)&lt;/code&gt; is defined recursively as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A(0) = seed
A(x) = HMAC_sha256(secret, A(x-1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result of the PRF is the final key that will be used for the bulk of the crypto in our application. We only want 48 bytes here, so we would need 2 rounds of SHA-256 and would discard the extra data.&lt;/p&gt;

&lt;h2 id=&#34;client-changecipherspec&#34;&gt;Client ChangeCipherSpec&lt;/h2&gt;

&lt;p&gt;The final unencrypted message sent by the client will be a ChangeCipherSpec message, which indicates that all following messages will be encrypted.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/change-cipher-spec.png&#34; alt=&#34;changecipherspec message&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;client-finished-server-changecipherspec-and-server-finished&#34;&gt;Client Finished, Server ChangeCipherSpec, and Server Finished&lt;/h2&gt;

&lt;p&gt;Immediately after sending a ChangeCipherSpec message, the client will send an encrypted Handshake Finished message to ensure the server is able to understand the agreed-upon encryption. The message will contain a &lt;strong&gt;hash of all previous handshake messages&lt;/strong&gt;, along with the string &amp;ldquo;client finished&amp;rdquo;. This is very important because it verifies that no part of the handshake has been tampered with by an attacker. It also includes the random bytes that were sent by the client and server, protecting it from replay attacks where the attacker pretends to be one of the parties.&lt;/p&gt;

&lt;p&gt;Once received by the server, the server will acknowledge with its own ChangeCipherSpec message, followed immediately by its own Finished message verifying the contents of the handshake.&lt;/p&gt;

&lt;p&gt;Note: if you have been following along in Wireshark, there appears to be a bug with Client/Server Finish messages when using AES_GCM that mislabels them.&lt;/p&gt;

&lt;h2 id=&#34;application-data&#34;&gt;Application Data&lt;/h2&gt;

&lt;p&gt;Finally, we can begin to transmit encrypted data! It may seem like a lot of work, but that is soon to pay off. The only remaining step is to discuss how the data is encrypted with AES_GCM, an &lt;a href=&#34;https://en.wikipedia.org/wiki/Authenticated_encryption&#34;&gt;AEAD&lt;/a&gt; cipher.&lt;/p&gt;

&lt;p&gt;First, we generate a MAC, key, and IV for both the client and the server using our master secret and the PRF definition from earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;key_data = PRF(master_secret, &amp;quot;key expansion&amp;quot;, server_random + client_random);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we are using 128-bit AES with SHA-256, we&amp;rsquo;ll pull out the following key data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// client_write_MAC_key = key_data[0..31]
// server_write_MAC_key = key_data[32..63]
client_write_key = key_data[64..79]
server_write_key = key_data[80..95]
client_write_IV = key_data[96..99]
server_write_IV = key_data[100..103]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For AEAD ciphers like GCM, we don&amp;rsquo;t need the MAC keys, but we offset them anyways. The client and server also get different keys to prevent a replay attack where a client message it looped back to it.&lt;/p&gt;

&lt;p&gt;We also construct &lt;code&gt;additional_data&lt;/code&gt; and an 8-byte &lt;code&gt;nonce&lt;/code&gt;, both of which are sent with the encrypted data. In the past, it was thought that the nonce could be either random or just a simple session counter. However, &lt;a href=&#34;https://github.com/nonce-disrespect/nonce-disrespect&#34;&gt;recent research&lt;/a&gt; found many sites using random nonces for AES_GCM were vulnerable to nonce reuse attacks, so it&amp;rsquo;s best to just use an incrementing counter tied to the session.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;additional_data = sequence_num + record_type + tls_version + length
nonce = &amp;lt;random_8_bytes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we can encrypt our data with AES GCM!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;encrypted = AES_GCM(client_write_key, client_write_IV+nonce, &amp;lt;DATA&amp;gt;, additional_data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the server can read it with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;DATA&amp;gt; = AES_GCM(client_write_key, client_write_IV+nonce, encrypted, additional_data)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://tlseminar.github.io/images/firstfew/tls-hs-ecdhe.png&#34; alt=&#34;tls 1.2 ecdhe handshake&#34; /&gt;
(source: &lt;a href=&#34;https://timtaubert.de/blog/2015/11/more-privacy-less-latency-improved-handshakes-in-tls-13/&#34;&gt;More Privacy, Less Latency: Improved Handshakes in TLS version 1.3&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all it takes to make a TLS 1.2 connection! Over the course of ~103ms, we established a bidirectional encrypted tunnel and sent a full HTTP request and response in only 2 round trips. Although we didn&amp;rsquo;t cover nearly everything in the &lt;a href=&#34;https://tools.ietf.org/html/rfc5246&#34;&gt;full TLS 1.2 RFC&lt;/a&gt;, we hope you have a pretty good overview of how process functions - and how much work goes in behind the scenes to secure web traffic!&lt;/p&gt;

&lt;h2 id=&#34;sources&#34;&gt;Sources&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html&#34;&gt;http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://security.stackexchange.com/questions/131724/the-first-few-milliseconds-of-an-https-connection-tls-1-2-tls-echde-rsa-with&#34;&gt;https://security.stackexchange.com/questions/131724/the-first-few-milliseconds-of-an-https-connection-tls-1-2-tls-echde-rsa-with&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5246&#34;&gt;https://tools.ietf.org/html/rfc5246&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5288&#34;&gt;https://tools.ietf.org/html/rfc5288&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.secg.org/sec2-v2.pdf&#34;&gt;http://www.secg.org/sec2-v2.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html&#34;&gt;https://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nonce-disrespect/nonce-disrespect&#34;&gt;https://github.com/nonce-disrespect/nonce-disrespect&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.trustworthyinternet.org/ssl-pulse/&#34;&gt;https://www.trustworthyinternet.org/ssl-pulse/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Blogging Mechanics</title>
      <link>https://tlseminar.github.io/blogging/</link>
      <pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://tlseminar.github.io/blogging/</guid>
      <description>&lt;p&gt;Here are some suggestions for how to create the class blog posts for
your assigned classes.  I believe each team has at least a few members
with enough experience using git and web contruction tools that
following these instructions won&amp;rsquo;t be a big burden, but if you have
other ways you want to build your blog page for a topic let me know
and we can discuss alternative options.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Install &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;.  Hugo is a static website
generator that builds a site from Markdown pages.  (With homebrew on
Mac OS X, this is easy: &lt;code&gt;brew update &amp;amp;&amp;amp; brew install hugo&lt;/code&gt;.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clone the github repository,
&lt;a href=&#34;https://github.com/tlseminar/tlseminar.github.io&#34;&gt;&lt;em&gt;https://github.com/tlseminar/tlseminar.github.io&lt;/em&gt;&lt;/a&gt;.
This is what is used to build the
&lt;a href=&#34;https://tlseminar.github.io&#34;&gt;tlseminar.github.io&lt;/a&gt; site.  If you are
working with multiple teammates on the blog post (which you probably
should be), you can add write permissions for everyone to the cloned
repository.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You should create your page in the &lt;code&gt;web/content/post/&lt;/code&gt;
subdirectory. You can start by copying an earlier file in that
directory (e.g., &lt;code&gt;class1.md&lt;/code&gt;) and updating the header section
(between the &lt;code&gt;+++&lt;/code&gt; marks) and replacing everything after that with
your content.  Don&amp;rsquo;t forget to update the date so your page will
appear in the right order.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can use multiple files (but probably only one in
the &lt;code&gt;post/&lt;/code&gt; directory (this will show up as pages on the front
list).  Use the &lt;code&gt;web/content/images&lt;/code&gt; directory for images and the
&lt;code&gt;web/content/docs&lt;/code&gt; directory for papers.  Using images and other
resources to make your post interesting and visually compelling is
highly encouraged!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write the blog page using Markdown.  Markdown is a simple markup
language that can be used to easily generate both HTML and other
output document formats.  You can probably figure out everything you
need by looking at previous posts, but for a summary of Markdown,
see &lt;a href=&#34;https://daringfireball.net/projects/markdown/syntax&#34;&gt;Markdown: Syntax&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To test the post, run &lt;code&gt;make develop&lt;/code&gt; (in the &lt;code&gt;web/&lt;/code&gt; subdirectory of
your repository).  This starts the Hugo development server, usually
on port 1313 (unless that port is already in use).  Then, you can
view the site with a browser at &lt;code&gt;localhost:1313&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When you are ready, submit a pull request to incorporate your
changes into the main repository (and public course website).  At
this stage, I will probably make things visible on the public site,
although it can still be edited and improved with subsequent
comments.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Class 1: Introduction</title>
      <link>https://tlseminar.github.io/class1/</link>
      <pubDate>Fri, 20 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://tlseminar.github.io/class1/</guid>
      <description>

&lt;p&gt;&lt;center&gt;
&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;c819c3c91461456ca328e97a753f6d56&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;plan&#34;&gt;Plan&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Find your team, introduce yourselves and figure out a management structure and plan.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bid for your role:&lt;br /&gt;
T (lead Class 2: oracle padding attacks)&lt;br /&gt;
L (blog Class 1/lead 3: breaking weak asymmetric crypto, Drown)&lt;br /&gt;
S (lead Class 4: certificates)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;examining-certificates&#34;&gt;Examining Certificates&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When does the certificate for &lt;a href=&#34;https://whitehouse.gov&#34;&gt;https://whitehouse.gov&lt;/a&gt; expire?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(won&amp;rsquo;t be able to answer this until later today) Does the new adminstration&amp;rsquo;s &lt;a href=&#34;https://whitehouse.gov&#34;&gt;https://whitehouse.gov&lt;/a&gt; site use the same private key as Obama&amp;rsquo;s?  (What should the answer to this question be?)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;first-few-milliseconds&#34;&gt;First Few Milliseconds&lt;/h1&gt;

&lt;p&gt;Jeff Moser&amp;rsquo;s &lt;a href=&#34;http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html&#34;&gt;&lt;em&gt;The First Few Milliseconds of an HTTPS Connection&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install &lt;a href=&#34;https://www.wireshark.org/download.html&#34;&gt;Wireshark&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start Wireshark, and look at all the TLS sessions running on your
laptop.  How many different TLS sessions are there?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pick one of the TLS sessions and try to figure out what application
is using it.  Who are the endpoints?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assuming (for now!) the encryption is all perfect, what could
someone intercepting the traffic learn?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What differences can you observe compared to what is described for the TLS 1.0 connections on that web page?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Background Preparation</title>
      <link>https://tlseminar.github.io/background/</link>
      <pubDate>Wed, 14 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tlseminar.github.io/background/</guid>
      <description>

&lt;p&gt;Here are some suggestions for getting the necessary background for the
seminar.&lt;/p&gt;

&lt;h2 id=&#34;cryptography&#34;&gt;Cryptography&lt;/h2&gt;

&lt;p&gt;If you have already taken a cryptography course, you should have
enough cryptography background already.  If not, here are some
suggested ways to get enough crypo background over winter break to be
ready for the seminar.  I believe that for most students, the best way
to get the expected background for this course is to take my Applied
Cryptography course (more info below), but there are many options, and
lots of great resources that go into much more depth than my course if
you have more time.&lt;/p&gt;

&lt;h3 id=&#34;on-line-courses&#34;&gt;On-Line Courses&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.udacity.com/course/applied-cryptography--cs387&#34;&gt;&lt;strong&gt;Udacity cs387: Applied
Cryptography&lt;/strong&gt;&lt;/a&gt;
- this is an open on-line course that you can take anytime taught by
myself (so I am somewhat partial to it!).  There are &lt;a href=&#34;http://www.cs.virginia.edu/~evans/courses/cs387/&#34;&gt;some additional
materials for the course
available&lt;/a&gt;,
including &lt;a href=&#34;http://www.cs.virginia.edu/~evans/courses/crypto-notes.pdf&#34;&gt;extensive course notes
(PDF)&lt;/a&gt;
created by Daniel Winter.  This is a very short and informal
introduction to cryptography, which would be enough background to be
prepared for the seminar.  (I can&amp;rsquo;t give an unbiased assessment of the
course, but according to Information Week, it is a recommended course
to &lt;a href=&#34;http://www.informationweek.com/strategic-cio/team-building-and-staffing/5-online-classes-to-pump-up-it-careers/d/d-id/898915&#34;&gt;&lt;em&gt;&amp;ldquo;Pump Up IT
Careers&amp;rdquo;&lt;/em&gt;&lt;/a&gt;,
and &lt;a href=&#34;www.prospectmagazine.co.uk/magazine/online-universities-udacity-grand-challenge-david-stavens-dave-evans&#34;&gt;Prospect
Magazine&lt;/a&gt;
claimed the instructor has a &amp;ldquo;Monty Python humor&amp;rdquo; and &amp;ldquo;cult
following&amp;rdquo;, although you shouldn&amp;rsquo;t believe everything you read in
British magazines.)&lt;/p&gt;

&lt;p&gt;Dan Boneh&amp;rsquo;s &lt;a href=&#34;https://www.coursera.org/learn/crypto&#34;&gt;&lt;strong&gt;Cryptography
Course&lt;/strong&gt;&lt;/a&gt; (offered through
Coursera).  The materials from previous courses are not available
(although you may be able to find them if you are resourceful), so you
have to take the course when it is offered by Coursera. There is a
session starting December 26.  This is an excellent course that is a
bit longer and goes into more depth on many topics than my course.
You can read &lt;a href=&#34;http://bryanpendleton.blogspot.com/2012/05/comparing-coursera-and-udacity.html&#34;&gt;Bryan Pendleton&amp;rsquo;s more objective
comparison&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Christoff Parr and Jan Pelzl&amp;rsquo;s &lt;a href=&#34;http://www.crypto-textbook.com/&#34;&gt;&lt;strong&gt;Understanding
Cryptography&lt;/strong&gt;&lt;/a&gt; textbook includes
Parr&amp;rsquo;s excellent &lt;a href=&#34;http://wiki.crypto.rub.de/Buch/movies.php&#34;&gt;video
lectures&lt;/a&gt; (chalkboard
style without editing, so takes some patience to watch).&lt;/p&gt;

&lt;h3 id=&#34;textbooks&#34;&gt;Textbooks&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.crypto101.io/&#34;&gt;Crypto 101&lt;/a&gt; - a very easy to read and
practically-focused introduction to cryptography (available as a &lt;a href=&#34;https://tlseminar.github.io/docs/Crypto101.pdf&#34;&gt;free,
creative-commons licensed PDF&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cs.umd.edu/~jkatz/imc.html&#34;&gt;&lt;em&gt;Introduction to Modern
Cryptography&lt;/em&gt;&lt;/a&gt;, Jonathan Katz
and Yehuda Lindell.  This provides a lot more depth that is required
for joining the seminar, but is an excellent book for ambitious
students with more time.&lt;/p&gt;

&lt;h2 id=&#34;computing-systems&#34;&gt;Computing Systems&lt;/h2&gt;

&lt;p&gt;Students in the class will benefit from understanding computing
systems and having experience with systems-level programming at least
at the level of a typical introductory operating systems course.
Students without this experience will either need to put a lot of
effort into learning it, or select projects and presentation topics
that focus on other aspects.&lt;/p&gt;

&lt;p&gt;Some resources for learning about computing systems are below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ops-class.org/&#34;&gt;&amp;ldquo;Hack the Kernel&amp;rdquo;&lt;/a&gt; - Operating Systems
class developed by &lt;a href=&#34;https://www.bluegroup.systems/people/gwa/&#34;&gt;Geoffrey
Challen&lt;/a&gt;.  Provides
programming assignments you can try on your own, as well as video
lectures and lots of on-line materials.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rust-class.org/&#34;&gt;cs4414: Operating Systems&lt;/a&gt; - Operating
systems course I taught in Fall 2013 and Spring 2014. Includes
&lt;a href=&#34;http://rust-class.org/pages/classes.html&#34;&gt;videos&lt;/a&gt; of lectures, and
programming assignments in Rust (some of which will need some updating
to work in the latest version of Rust).&lt;/p&gt;

&lt;p&gt;CMU&amp;rsquo;s &lt;a href=&#34;http://csapp.cs.cmu.edu/&#34;&gt;Computing Systems&lt;/a&gt; course and
textbook by Randal Bryant and David O&amp;rsquo;Hallaron provides an excellent
introduction to systems programming, as well as a series of &lt;a href=&#34;http://csapp.cs.cmu.edu/3e/labs.html&#34;&gt;fun
self-study labs&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;rust-programming&#34;&gt;Rust Programming&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m hoping several of the projects will involve contribution to open
source projects using Rust to provide secure, efficient, and
iter-operable implementations of TLS and other cryptographic
functionalities.  It is not a requirement that you use Rust in this
class, but everyone will be encouraged to get some experience with it.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/nightly/book/&#34;&gt;&lt;strong&gt;Rust Programming Language
Book&lt;/strong&gt;&lt;/a&gt; (this is the
&amp;ldquo;official&amp;rdquo; Rust book, which includes a tutorial to get started)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://aml3.github.io/RustTutorial/&#34;&gt;&lt;strong&gt;Rust Tutorial&lt;/strong&gt;&lt;/a&gt; (this was
developed for my &lt;a href=&#34;https://rust-class.org/&#34;&gt;cs4414 class&lt;/a&gt; by Alex
Lamana, Rob Michaels, and Wil Thomason.  (Some parts may need updating
to latest version of Rust, so if you go through this, please submit
updates as pull requests!)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rustbyexample.com/&#34;&gt;&lt;strong&gt;Rust by Example&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Welcome to TLSeminar!</title>
      <link>https://tlseminar.github.io/welcome/</link>
      <pubDate>Wed, 14 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tlseminar.github.io/welcome/</guid>
      <description>&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;http://xkcd.com/1353/&#34;&gt;
&lt;img src=&#34;//imgs.xkcd.com/comics/heartbleed.png&#34; title=&#34;I looked at some of the data dumps from vulnerable sites, and it was ... bad. I saw emails, passwords, password hints. SSL keys and session cookies. Important servers brimming with visitor IPs. Attack ships on fire off the shoulder of Orion, c-beams glittering in the dark near the Tannhäuser Gate. I should probably patch OpenSSL.&#34; alt=&#34;Heartbleed&#34; srcset=&#34;//imgs.xkcd.com/comics/heartbleed_2x.png 2x&#34;&gt;
&lt;/img&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;This is the course site for &lt;strong&gt;cs6501: Understanding and Securing
TLS&lt;/strong&gt;. [&lt;a href=&#34;https://tlseminar.github.io/syllabus&#34;&gt;Syllabus&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;The first class is Friday, 20 January 2017 (9:30am-noon in Thornton
Hall D115).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>